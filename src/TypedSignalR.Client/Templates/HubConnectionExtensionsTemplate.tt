<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    static string CreateTypeParametersString(int num)
    {
        if (num <= 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.Append("T1");

        for (int i = 2; i <= num; i++)
        {
            sb.Append($", T{i}");
        }

        return sb.ToString();
    }

    static string CreateHandlerArgumentsString(int num)
    {
        if (num <= 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.Append("(T1)args[0]!");

        for (int i = 2; i <= num; i++)
        {
            sb.Append($", (T{i})args[{i - 1}]!");
        }

        return sb.ToString();
    }
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client
// </auto-generated>
#nullable enable
namespace TypedSignalR.Client
{
    public static partial class HubConnectionExtensions
    {
        public static THub CreateHubProxy<THub>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var hubInvokerFactory = HubInvokerFactoryProvider.GetHubInvokerFactory<THub>();

            if (hubInvokerFactory is null)
            {
                throw new global::System.InvalidOperationException($"Failed to create hub proxy. TypedSignalR.Client did not generate source code to create hub proxy, which type is {typeof(THub)}.");
            }

            return hubInvokerFactory.CreateHubInvoker(connection, cancellationToken);
        }

        public static global::System.IDisposable Register<TReceiver>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, TReceiver receiver)
        {
            if (receiver is null)
            {
                throw new global::System.ArgumentNullException(nameof(receiver));
            }

            if (typeof(TReceiver) == typeof(IHubConnectionObserver))
            {
#pragma warning disable CS8604
                return new HubConnectionObserverSubscription(connection, receiver as IHubConnectionObserver);
#pragma warning restore CS8604
            }

            var binder = ReceiverBinderProvider.GetReceiverBinder<TReceiver>();

            if (binder is null)
            {
                throw new global::System.InvalidOperationException($"Failed to register receiver. TypedSignalR.Client did not generate source code to register receiver, which type is {typeof(TReceiver)}.");
            }

            var subscription = binder.Bind(connection, receiver);

            if (receiver is IHubConnectionObserver hubConnectionObserver)
            {
                subscription = new CompositeDisposable(new[] { subscription, new HubConnectionObserverSubscription(connection, hubConnectionObserver) });
            }

            return subscription;
        }
    }

    public static partial class HubConnectionExtensions
    {
        private static global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory>? Factories = default;
        private static global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder>? Binders = default;

        private static partial void InitializeFactories();
        private static partial void InitializeBinders();

        static HubConnectionExtensions()
        {
            InitializeFactories();
            InitializeBinders();
        }

        private static class HubInvokerFactoryProvider
        {
            public static IHubInvokerFactory<T>? GetHubInvokerFactory<T>()
            {
                return Cache<T>.HubInvokerFactory;
            }

            private static class Cache<T>
            {
                public static readonly IHubInvokerFactory<T>? HubInvokerFactory = default;

                static Cache()
                {
                    if (Factories is null)
                    {
                        InitializeFactories();
                    }

                    if (Factories.TryGetValue(typeof(T), out var hubInvokerFactory))
                    {
                        HubInvokerFactory = hubInvokerFactory as IHubInvokerFactory<T>;
                    }
                }
            }
        }

        private static class ReceiverBinderProvider
        {
            public static IReceiverBinder<T>? GetReceiverBinder<T>()
            {
                return Cache<T>.ReceiverBinder;
            }

            private static class Cache<T>
            {
                public static readonly IReceiverBinder<T>? ReceiverBinder = default;

                static Cache()
                {
                    if (Binders is null)
                    {
                        InitializeBinders();
                    }

                    if (Binders.TryGetValue(typeof(T), out var receiverBinder))
                    {
                        ReceiverBinder = receiverBinder as IReceiverBinder<T>;
                    }
                }
            }
        }

        private sealed class HubConnectionObserverSubscription : global::System.IDisposable
        {
            private readonly global::Microsoft.AspNetCore.SignalR.Client.HubConnection _connection;
            private readonly IHubConnectionObserver _hubConnectionObserver;

            private int _disposed = 0;

            public HubConnectionObserverSubscription(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, IHubConnectionObserver hubConnectionObserver)
            {
                _connection = connection;
                _hubConnectionObserver = hubConnectionObserver;

                _connection.Closed += hubConnectionObserver.OnClosed;
                _connection.Reconnected += hubConnectionObserver.OnReconnected;
                _connection.Reconnecting += hubConnectionObserver.OnReconnecting;
            }

            public void Dispose()
            {
                if (global::System.Threading.Interlocked.Exchange(ref _disposed, 1) == 0)
                {
                    _connection.Closed -= _hubConnectionObserver.OnClosed;
                    _connection.Reconnected -= _hubConnectionObserver.OnReconnected;
                    _connection.Reconnecting -= _hubConnectionObserver.OnReconnecting;
                }
            }
        }

        private sealed class CompositeDisposable : global::System.IDisposable
        {
            private readonly object _gate = new object();
            private readonly global::System.Collections.Generic.List<global::System.IDisposable> _disposables;

            private bool _disposed;

            public CompositeDisposable()
            {
                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>();
            }

            public CompositeDisposable(global::System.IDisposable[] disposables)
            {
                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(disposables);
            }

            public CompositeDisposable(int capacity)
            {
                if (capacity < 0)
                {
                    throw new global::System.ArgumentOutOfRangeException(nameof(capacity));
                }

                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(capacity);
            }

            public void Add(global::System.IDisposable item)
            {
                bool shouldDispose = false;

                lock (_gate)
                {
                    shouldDispose = _disposed;

                    if (!_disposed)
                    {
                        _disposables.Add(item);
                    }
                }

                if (shouldDispose)
                {
                    item.Dispose();
                }
            }

            public void Dispose()
            {
                var currentDisposables = default(global::System.Collections.Generic.List<global::System.IDisposable>);

                lock (_gate)
                {
                    if (_disposed)
                    {
                        return;
                    }

                    _disposed = true;
                    currentDisposables = _disposables;
                }

                foreach (var item in currentDisposables)
                {
                    if (item is not null)
                    {
                        item.Dispose();
                    }
                }

                currentDisposables.Clear();
            }
        }

        // It is not possible to avoid boxing.
        // This is a limitation caused by the SignalR implementation.
        private static class HandlerConverter
        {
            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert(global::System.Func<global::System.Threading.Tasks.Task> handler)
            {
                return args => handler();
            }
<# for(int i = 1; i <= 16; i++) { #>
            
            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<<#= CreateTypeParametersString(i) #>>(global::System.Func<<#= CreateTypeParametersString(i) #>, global::System.Threading.Tasks.Task> handler)
            {
                return args => handler(<#= CreateHandlerArgumentsString(i) #>);
            }
<# } #>
        }
    }
}
