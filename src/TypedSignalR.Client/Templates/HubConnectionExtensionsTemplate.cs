using System.Text;

public sealed class HubConnectionExtensionsTemplate
{
    private const string TemplateText1 = """
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client
// </auto-generated>
#nullable enable
#pragma warning disable CS1591
namespace TypedSignalR.Client
{
    internal static partial class HubConnectionExtensions
    {
        public static THub CreateHubProxy<THub>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken = default)
        {
            var factory = HubInvokerFactoryProvider.GetHubInvokerFactory<THub>();

            if (factory is null)
            {
                throw new global::System.InvalidOperationException($"Failed to create a hub proxy. TypedSignalR.Client did not generate source code to create a hub proxy, which type is {typeof(THub)}.");
            }

            return factory.CreateHubInvoker(connection, cancellationToken);
        }

        public static global::System.IDisposable Register<TReceiver>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, TReceiver receiver)
        {
            if (receiver is null)
            {
                throw new global::System.ArgumentNullException(nameof(receiver));
            }

            if (typeof(TReceiver) == typeof(IHubConnectionObserver))
            {
                return new HubConnectionObserverSubscription(connection, (IHubConnectionObserver)receiver);
            }

            var binder = ReceiverBinderProvider.GetReceiverBinder<TReceiver>();

            if (binder is null)
            {
                throw new global::System.InvalidOperationException($"Failed to register a receiver. TypedSignalR.Client did not generate source code to register a receiver, which type is {typeof(TReceiver)}.");
            }

            var subscription = binder.Bind(connection, receiver);

            if (receiver is IHubConnectionObserver hubConnectionObserver)
            {
                subscription = new CompositeDisposable(new[] { subscription, new HubConnectionObserverSubscription(connection, hubConnectionObserver) });
            }

            return subscription;
        }
    }

    internal static partial class HubConnectionExtensions
    {
        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory> CreateFactories();
        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder> CreateBinders();

        private static class HubInvokerFactoryProvider
        {
            private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory> Factories;

            static HubInvokerFactoryProvider()
            {
                Factories = CreateFactories();
            }

            public static IHubInvokerFactory<T>? GetHubInvokerFactory<T>()
            {
                return Cache<T>.HubInvokerFactory;
            }

            private static class Cache<T>
            {
                public static readonly IHubInvokerFactory<T>? HubInvokerFactory = default;

                static Cache()
                {
                    if (Factories.TryGetValue(typeof(T), out var hubInvokerFactory))
                    {
                        HubInvokerFactory = hubInvokerFactory as IHubInvokerFactory<T>;
                    }
                }
            }
        }

        private static class ReceiverBinderProvider
        {
            private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder> Binders;

            static ReceiverBinderProvider()
            {
                Binders = CreateBinders();
            }

            public static IReceiverBinder<T>? GetReceiverBinder<T>()
            {
                return Cache<T>.ReceiverBinder;
            }

            private static class Cache<T>
            {
                public static readonly IReceiverBinder<T>? ReceiverBinder = default;

                static Cache()
                {
                    if (Binders.TryGetValue(typeof(T), out var receiverBinder))
                    {
                        ReceiverBinder = receiverBinder as IReceiverBinder<T>;
                    }
                }
            }
        }

        private sealed class HubConnectionObserverSubscription : global::System.IDisposable
        {
            private readonly global::Microsoft.AspNetCore.SignalR.Client.HubConnection _connection;
            private readonly IHubConnectionObserver _hubConnectionObserver;

            private int _disposed = 0;

            public HubConnectionObserverSubscription(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, IHubConnectionObserver hubConnectionObserver)
            {
                _connection = connection;
                _hubConnectionObserver = hubConnectionObserver;

                _connection.Closed += hubConnectionObserver.OnClosed;
                _connection.Reconnected += hubConnectionObserver.OnReconnected;
                _connection.Reconnecting += hubConnectionObserver.OnReconnecting;
            }

            public void Dispose()
            {
                if (global::System.Threading.Interlocked.Exchange(ref _disposed, 1) == 0)
                {
                    _connection.Closed -= _hubConnectionObserver.OnClosed;
                    _connection.Reconnected -= _hubConnectionObserver.OnReconnected;
                    _connection.Reconnecting -= _hubConnectionObserver.OnReconnecting;
                }
            }
        }

        private sealed class CompositeDisposable : global::System.IDisposable
        {
            private readonly object _gate = new object();
            private readonly global::System.Collections.Generic.List<global::System.IDisposable> _disposables;

            private bool _disposed;

            public CompositeDisposable()
            {
                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>();
            }

            public CompositeDisposable(global::System.IDisposable[] disposables)
            {
                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(disposables);
            }

            public CompositeDisposable(int capacity)
            {
                if (capacity < 0)
                {
                    throw new global::System.ArgumentOutOfRangeException(nameof(capacity));
                }

                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(capacity);
            }

            public void Add(global::System.IDisposable item)
            {
                bool shouldDispose = false;

                lock (_gate)
                {
                    shouldDispose = _disposed;

                    if (!_disposed)
                    {
                        _disposables.Add(item);
                    }
                }

                if (shouldDispose)
                {
                    item.Dispose();
                }
            }

            public void Dispose()
            {
                var currentDisposables = default(global::System.Collections.Generic.List<global::System.IDisposable>);

                lock (_gate)
                {
                    if (_disposed)
                    {
                        return;
                    }

                    _disposed = true;
                    currentDisposables = _disposables;
                }

                foreach (var item in currentDisposables)
                {
                    if (item is not null)
                    {
                        item.Dispose();
                    }
                }

                currentDisposables.Clear();
            }
        }

""";

    private const string TemplateText3 = """
        }
    }
}
#pragma warning restore CS1591
""";

    public string TransformText()
    {
        var sb = new StringBuilder();

        sb.AppendLine(TemplateText1);
        AppendTemplateText2(sb);
        sb.AppendLine(TemplateText3);

        return sb.ToString();
    }

    private static void AppendTemplateText2(StringBuilder stringBuilder)
    {
        stringBuilder.AppendLine("""
        // It is not possible to avoid boxing.
        // This is a limitation caused by the SignalR implementation.
        private static class HandlerConverter
        {
            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert(global::System.Func<global::System.Threading.Tasks.Task> handler)
            {
                return args => handler();
            }
""");

        for (int i = 1; i <= 16; i++)
        {
            stringBuilder.AppendLine($$"""

            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<{{CreateTypeParametersString(i)}}>(global::System.Func<{{CreateTypeParametersString(i)}}, global::System.Threading.Tasks.Task> handler)
            {
                return args => handler({{CreateHandlerArgumentsString(i)}});
            }
""");
        }

        stringBuilder.AppendLine("""

            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<TResult>(global::System.Func<global::System.Threading.Tasks.Task<TResult>> handler)
            {
                return async args =>
                {
                    var result = await handler().ConfigureAwait(false);
                    return result;
                };
            }
""");
        for (int i = 1; i <= 16; i++)
        {
            stringBuilder.AppendLine($$"""

            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<{{CreateTypeParametersString(i)}}, TResult>(global::System.Func<{{CreateTypeParametersString(i)}}, global::System.Threading.Tasks.Task<TResult>> handler)
            {
                return async args =>
                {
                    var result = await handler({{CreateHandlerArgumentsString(i)}}).ConfigureAwait(false);
                    return result;
                };
            }
""");
        }
    }

    private static string CreateTypeParametersString(int num)
    {
        if (num <= 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.Append("T1");

        for (int i = 2; i <= num; i++)
        {
            sb.Append($", T{i}");
        }

        return sb.ToString();
    }

    private static string CreateHandlerArgumentsString(int num)
    {
        if (num <= 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.Append("(T1)args[0]!");

        for (int i = 2; i <= num; i++)
        {
            sb.Append($", (T{i})args[{i - 1}]!");
        }

        return sb.ToString();
    }
}
